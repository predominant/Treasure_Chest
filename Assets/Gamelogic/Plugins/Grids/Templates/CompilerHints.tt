//----------------------------------------------//
// Gamelogic Grids                              //
// http://www.gamelogic.co.za                   //
// Copyright (c) 2013 Gamelogic (Pty) Ltd       //
//----------------------------------------------//

// Auto-generated File

using System.Linq;
using System.Collections.Generic;

namespace Gamelogic.Grids
{
	/**
		Place holder class.

		@since 1.6
	*/
	public class __CellType{}

	/**
		This class provides static methods that ensure all the code is 
		generated by to AOT compiler for iOS. 

		The easiest way to use it is to copy the appropriate methods to
		one of your classes, modify the __CellType type, and call the methods.

		@since 1.6
	*/
	public static class __CompilerHints
	{
<#
	foreach(var gridType in UniformGrids)
	{
		var baseGrid = BaseGrids[gridType];
#>

		public static bool __CompilerHint__<#=gridType#>()
		{
			return __CompilerHint1__<#=gridType#>() && __CompilerHint2__<#=gridType#>();
		}

		/** 
			Call this method if you use a <#=gridType#>Grid.
			Replace	the type __CellType to whatever type you have in your grid.

			You can call the method anywhere in your code.
			
				if(!__CompilerHint__<#=gridType#>()) return;

			This methods always returns true.

			@since 1.6
		*/
		public static bool __CompilerHint1__<#=gridType#>()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new <#=baseGrid#>Grid<__CellType[]>(1, 1);

			foreach(var point in grid)
			{
				grid[point] = new __CellType[1];
			} 

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<<#=gridType#>Point>(new IntRect(), p => true);
			var shapeInfo = new <#=gridType#>ShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()][0] == null || shapeInfo.Translate(<#=baseGrid#>Point.Zero) != null;
		}

		public static bool __CompilerHint2__<#=gridType#>()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new <#=gridType#>Grid<__CellType>(1, 1, p => p == <#=gridType#>Point.Zero, x => x, x => x, new List<<#=gridType#>Point>());

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<<#=gridType#>Point>(new IntRect(), p => true);
			var shapeInfo = new <#=gridType#>ShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()] == null || shapeInfo.Translate(<#=gridType#>Point.Zero) != null;
		}

<#
	}

	foreach(var gridType in SplicedGrids)
	{
		var baseGrid = BaseGrids[gridType];
#>

		/** 
			Call this method if you use a <#=gridType#>Grid.
			Replace	the type __CellType to whatever type you have in your grid.

			You can call the method anywhere in your code.
			
				if(!__CompilerHint__<#=gridType#>()) return;

			This methods always returns true.

			@since 1.6
		*/
		public static bool __CompilerHint__<#=gridType#>()
		{
			//Ensures abstract super classes for base grids gets created
			var grid = new <#=baseGrid#>Grid<__CellType[]>(1, 1);

			foreach(var point in grid)
			{
				grid[point] = new __CellType[1];
			} 

			//Ensures shape infpo classes get created
			var shapeStorageInfo = new ShapeStorageInfo<<#=gridType#>Point>(new IntRect(), p => true);
			var shapeInfo = new <#=gridType#>ShapeInfo<__CellType>(shapeStorageInfo);

			return grid[grid.First()][0] == null || shapeInfo.IncIndex(0) != null;
		}
<#
	}
#>
	}
}